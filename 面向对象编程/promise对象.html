<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>promise对象</title>
		<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
		<style type="text/css">
			*{
				margin:0;
				padding:0;
			}
			html,body{
				height:100%;
				width:100%;
			}
			html{
				font-size:20px;
			}
			main{
				font-size:0.8rem;
				width:30rem;
				height:auto;
				margin:2rem auto;
				padding:1rem;
				border:0.1rem solid black;
				box-shadow:0 0 0.5rem 0.5rem #666;
			}
			h3{
				height:2rem;
				line-height:2rem;
				text-align:center;
				background-color:black;
				color:white;
			}
			ul{
				list-style-position:inside;
				padding:1rem;
			}
			ul li{
				margin:0.5rem 0;
			}
		</style>
		<style>
			@media (max-width:450px) {
				main{
					width:auto;
					height:auto;
					margin:0;
					padding:0;
				}
			}
		</style>
	</head>
	<body>
		<main>
			<h3>promise对象</h3>
			<section>
				<ul>
					<li>Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</li>
					<li>Promise 是一个对象，也是一个构造函数。</li>
					<li>Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个then方法，用来指定下一步的回调函数。</li>
				</ul>
			</section>
			<section>
				<h3>promise对象的状态</h3>
				<ul>
					<li>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</li>
					<li>异步操作未完成（pending）</li>
					<li>异步操作成功（fulfilled）</li>
					<li>异步操作失败（rejected）</li>
				</ul>
			</section>
			<section>
				<h3>promise构造函数</h3>
				<ul>
					<li>JavaScript 提供原生的Promise构造函数，用来生成 Promise 实例。</li>
					<li>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。</li>
					<li>resolve函数的作用是，将Promise实例的状态从“未完成”变为“成功”（即从pending变为fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。reject函数的作用是，将Promise实例的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>
				</ul>
			</section>
			<section>
				<h3>Promise.prototype.then() </h3>
				<ul>
					<li>Promise 实例的then方法，用来添加回调函数。</li>
					<li>then方法可以接受两个回调函数，第一个是异步操作成功时（变为fulfilled状态）的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。</li>
					<li>then方法可以链式使用。</li>
				</ul>
			</section>
			<section>
				<h3>then() 用法辨析 </h3>
				<ul>
					<li>Promise 的用法，简单说就是一句话：使用then方法添加回调函数。</li>
					<li>Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。</li>
					<li>Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。</li>
					<li>Promise 的回调函数属于异步任务，会在同步任务之后执行。</li>
				</ul>
			</section>
		</main>
	</body>
</html>
