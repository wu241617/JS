<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
		<link rel="stylesheet" href="./index.css">
		<style>
			@media (max-width:450px) {
				main{
					height:auto;
					width:auto;
					padding:0;
					margin:0;
				}
				h2:nth-child(1){
					margin-top:0;
				}
			}
		</style>
		<title>Node接口</title>
	</head>
	<body>
		<main>
			<h2>Node 接口</h2>
			<section>
				<ul>
					<li>所有 DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法。这是 DOM 操作的基础。</li>
				</ul>
			</section>
			<h2>属性</h2>
			<section>
				<ul>
					<h3>Node.prototype.nodeType </h3>
					<li>nodeType属性返回一个整数值，表示节点的类型</li>
					<li>不同节点的nodeType属性值和对应的常量如下。</li>
					<li>文档节点（document）：9，对应常量Node.DOCUMENT_NODE</li>
					<li>元素节点（element）：1，对应常量Node.ELEMENT_NODE</li>
					<li>属性节点（attr）：2，对应常量Node.ATTRIBUTE_NODE</li>
					<li>文本节点（text）：3，对应常量Node.TEXT_NODE</li>
					<li>文档片断节点（DocumentFragment）：11，对应常量Node.DOCUMENT_FRAGMENT_NODE</li>
					<li>文档类型节点（DocumentType）：10，对应常量Node.DOCUMENT_TYPE_NODE</li>
					<li>注释节点（Comment）：8，对应常量Node.COMMENT_NODE</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.nodeName</h3>
				<ul>
					<li>nodeName属性返回节点的名称</li>
					<li>不同的节点的 nodeName 属性值如下</li>
					<li>文档节点（document）：#document</li>
					<li>元素节点（element）：大写的标签名</li>
					<li>属性节点（attr）：属性的名称</li>
					<li>文本节点（text）：#text</li>
					<li>文档片断节点（DocumentFragment）：#document-fragment</li>
					<li>文档类型节点（DocumentType）：文档的类型</li>
					<li>注释节点（Comment）：#comment</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.nodeValue</h3>
				<ul>
					<li>nodeVaule属性返回一个字符串，表示当前节点本身的文本值，该属性可读写</li>
					<li>只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的nodeValue可以返回结果，其他类型的节点一律返回null。同样的，也只有这三类节点可以设置nodeValue属性的值，其他类型的节点设置无效。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.textContent</h3>
				<ul>
					<li>textContent属性返回当前节点和它的所有后代节点的文本内容</li>
					<li>textContent属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。</li>
					<li>该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它还有一个好处，就是自动对 HTML 标签转义。这很适合用于用户提供的内容。</li>
					<li>文档节点（document）和文档类型节点（doctype）的textContent属性为null。如果要读取整个文档的内容，可以使用document.documentElement.textContent。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.baseURL</h3>
				<ul>
					<li>baseURI属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。</li>
					<li>如果无法读到网页的 URL，baseURI属性返回null。</li>
					<li>该属性的值一般由当前网址的 URL（即window.location属性）决定，但是可以使用 HTML 的<base>标签，改变该属性的值。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.ownerDocument</h3>
				<ul>
					<li>Node.ownerDocument属性返回当前节点所在的顶层文档对象，即document对象。</li>
					<li>document对象本身的ownerDocument属性，返回null。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.nextSibling</h3>
				<ul>
					<li>Node.nextSibling属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。</li>
					<li>该属性还包括文本节点和注释节点（<!-- comment -->）。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.previousSibling</h3>
				<ul>
					<li>previousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null。</li>
					<li>该属性还包括文本节点和注释节点。因此如果当前节点前面有空格，该属性会返回一个文本节点，内容为空格。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype/parentNode</h3>
				<ul>
					<li>parentNode属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。</li>
					<li>文档节点（document）和文档片段节点（documentfragment）的父节点都是null。另外，对于那些生成后还没插入 DOM 树的节点，父节点也是null。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.parentElement</h3>
				<ul>
					<li>parentElement属性返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回null。</li>
					<li>由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。parentElement属性相当于把后两种父节点都排除了。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.firstChild</h3>
				<ul>
					<li>firstChild属性返回当前节点的第一个子节点，如果当前节点的没有子节点，则返回null</li>
					<li>firstChild返回的除了元素节点，还可能是文本节点或注释节点。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.lastChild</h3>
				<ul>
					<li>lastChild属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回null。</li>
					<li>lastChild返回的除了元素节点，还可能是文本节点或注释节点。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.childNodes</h3>
				<ul>
					<li>childNodes属性返回一个类似数组的对象（NodeList集合），成员包括当前节点的所有子节点。</li>
					<li>文档节点（document）就有两个子节点：文档类型节点（docType）和 HTML 根元素节点。</li>
					<li>除了元素节点，childNodes属性的返回值还包括文本节点和注释节点。如果当前节点不包括任何子节点，则返回一个空的NodeList集合。由于NodeList对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.isConnected</h3>
				<ul>
					<li>isConnected属性返回一个布尔值，表示当前节点是否在文档之中。</li>
				</ul>
			</section>
			<h2>方法</h2>
			<section>
				<h3>Node.prototype.appendChild()</h3>
				<ul>
					<li>appendChild()方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。</li>
					<li>如果参数节点是 DOM 已经存在的节点，appendChild()方法会将其从原来的位置，移动到新位置。</li>
					<li>如果appendChild()方法的参数是DocumentFragment节点，那么插入的是DocumentFragment的所有子节点，而不是DocumentFragment节点本身。返回值是一个空的DocumentFragment节点。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.hasChildNodes()</h3>
				<ul>
					<li>hasChildNodes方法返回一个布尔值，表示当前节点是否有子节点。</li>
					<li>子节点包括所有类型的节点，并不仅仅是元素节点。哪怕节点只包含一个空格，hasChildNodes方法也会返回true。</li>
					<li>判断一个节点有没有子节点方法</li>
					<li>node.hasChildNodes()</li>
					<li>node.firstChild !== null</li>
					<li>node.childNodes && node.childNodes.length > 0</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.cloneNode()</h3>
				<ul>
					<li>cloneNode方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</li>
					<li>克隆一个节点，会拷贝该节点的所有属性，但是会丧失addEventListener方法和on-属性（即node.onclick = fn），添加在这个节点上的事件回调函数。</li>
					<li>该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如Node.appendChild这样的方法添加到文档之中。</li>
					<li>克隆一个节点之后，DOM 有可能出现两个有相同id属性（即id="xxx"）的网页元素，这时应该修改其中一个元素的id属性。如果原节点有name属性，可能也需要修改。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.insertBefore</h3>
				<ul>
					<li>insertBefore方法用于将某个节点插入父节点内部的指定位置。</li>
					<li>insertBefore方法接受两个参数，第一个参数是所要插入的节点newNode，第二个参数是父节点parentNode内部的一个子节点referenceNode。newNode将插在referenceNode这个子节点的前面。返回值是插入的新节点newNode。</li>
					<li>如果insertBefore方法的第二个参数为null，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</li>
					<li>如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。</li>
				</ul>
			</section>
			<section>
				<h3>insertAfter方法</h3>
				<ul>
					<li>由于不存在insertAfter方法，如果新节点要插在父节点的某个子节点后面，可以用insertBefore方法结合nextSibling属性模拟。</li>
					<li>parent.insertBefore(s1, s2.nextSibling);</li>
					<li>如果要插入的节点是DocumentFragment类型，那么插入的将是DocumentFragment的所有子节点，而不是DocumentFragment节点本身。返回值将是一个空的DocumentFragment节点。</li>
				</ul>
			</section>
			<section>
				<h3>Node.protype.removeChild()</h3>
				<ul>
					<li>removeChild方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</li>
					<li>这个方法是在divA的父节点上调用的，不是在divA上调用的。divA.parentNode.removeChild(divA);</li>
					<li>如果参数节点不是当前节点的子节点，removeChild方法将报错。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.replaceChild()</h3>
					<ul>
						<li>replaceChild方法用于将一个新的节点，替换当前节点的某一个子节点。</li>
						<li>var replacedNode = parentNode.replaceChild(newChild, oldChild);</li>
						<li>replaceChild方法接受两个参数，第一个参数newChild是用来替换的新节点，第二个参数oldChild是将要替换走的子节点。返回值是替换走的那个节点oldChild。</li>
					</ul>
			</section>
			<section>
				<h3>Node.prototype.contains()</h3>
				<ul>
					<li>contains方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。</li>
					<li>参数节点为当前节点。</li>
					<li>参数节点为当前节点的子节点。</li>
					<li>参数节点为当前节点的后代节点。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.compareDocumentPosition()</h3>
				<ul>
					<li>compareDocumentPosition方法的用法，与contains方法完全一致，返回一个六个比特位的二进制值，表示参数节点与当前节点的关系。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.isEqualNode()</h3>
				<ul>
					<li>sEqualNode方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.isSameNode() </h3>
				<ul>
					<li>isSameNode方法返回一个布尔值，表示两个节点是否为同一个节点。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.normalize()</h3>
				<ul>
					<li>normalize方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。</li>
				</ul>
			</section>
			<section>
				<h3>Node.prototype.getRootNode()</h3>
				<ul>
					<li>getRootNode()方法返回当前节点所在文档的根节点document，与ownerDocument属性的作用相同。</li>
					<li>该方法可用于document节点自身，这一点与document.ownerDocument不同。</li>
				</ul>
			</section>
		</main>
	</body>
</html>
